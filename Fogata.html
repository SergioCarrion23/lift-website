<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Fogata Â· Salmo 51:10</title>
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&family=Cinzel:wght@300;400&display=swap" rel="stylesheet">
<style>
  * { margin:0;padding:0;box-sizing:border-box; }
  body { overflow:hidden; background:#080604; font-family:'Cormorant Garamond',serif; }

  /* HINT */
  #hint {
    position:fixed;top:28px;left:50%;transform:translateX(-50%);
    color:rgba(255,130,30,0.22); font-size:10px;letter-spacing:7px;
    text-transform:uppercase;user-select:none;
    font-family:'Cinzel',serif; font-weight:300;
  }

  /* BUTTON WRAP */
  #btn-wrap {
    position:fixed;bottom:48px;left:50%;transform:translateX(-50%);z-index:10;
    display:flex;flex-direction:column;align-items:center;gap:0;
  }

  /* ELEGANT BUTTON */
  #btn-paper {
    position:relative;
    padding:0;
    background:transparent;
    border:none;
    cursor:pointer;
    outline:none;
    transition:all 0.5s ease;
    font-family:'Cinzel',serif;
  }

  .btn-inner {
    position:relative;
    display:flex;align-items:center;gap:14px;
    padding:16px 46px;
    border:1px solid rgba(255,140,40,0.35);
    color:rgba(255,185,90,0.85);
    font-size:11px;letter-spacing:5px;text-transform:uppercase;
    font-family:'Cinzel',serif; font-weight:300;
    background: linear-gradient(135deg, rgba(20,10,3,0.9), rgba(30,14,4,0.95));
    backdrop-filter:blur(12px);
    transition:all 0.5s ease;
    clip-path: polygon(12px 0%, 100% 0%, calc(100% - 12px) 100%, 0% 100%);
  }

  /* Corner ornaments */
  .btn-inner::before, .btn-inner::after {
    content:'';position:absolute;width:7px;height:7px;
    border-color:rgba(255,150,50,0.6);border-style:solid;
    transition:all 0.4s ease;
  }
  .btn-inner::before { top:-1px;left:-1px;border-width:1px 0 0 1px; }
  .btn-inner::after  { bottom:-1px;right:-1px;border-width:0 1px 1px 0; }

  /* Glow line under button */
  .btn-glow {
    width:60%;height:1px;
    background: linear-gradient(90deg, transparent, rgba(255,120,30,0.6), transparent);
    margin-top:0;
    animation: glowPulse 3s ease-in-out infinite;
  }

  .btn-icon {
    font-size:15px;
    filter: drop-shadow(0 0 6px rgba(255,120,0,0.8));
    transition:transform 0.4s ease;
  }

  #btn-paper:hover .btn-inner {
    border-color:rgba(255,160,60,0.65);
    color:rgba(255,210,120,0.95);
    background: linear-gradient(135deg, rgba(30,14,4,0.95), rgba(45,20,5,0.98));
    box-shadow:
      0 0 30px rgba(255,100,0,0.15),
      inset 0 0 20px rgba(255,80,0,0.06);
  }
  #btn-paper:hover .btn-icon { transform:rotate(-8deg) scale(1.15); }

  #btn-paper:active .btn-inner { transform:scale(0.97); }
  #btn-paper:disabled { opacity:0.2; cursor:default; pointer-events:none; }
  #btn-paper:disabled .btn-inner { border-color:rgba(255,100,30,0.15); }

  @keyframes glowPulse {
    0%,100%{ opacity:0.4;width:40%; }
    50%{ opacity:0.9;width:70%; }
  }

  /* VERSE OVERLAY */
  #verse-overlay {
    position:fixed;inset:0;z-index:100;
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    pointer-events:none;
    opacity:0;
    transition:opacity 2.5s ease;
    background: radial-gradient(ellipse at center, rgba(20,8,2,0.0) 0%, rgba(8,6,4,0.0) 100%);
  }
  #verse-overlay.show {
    opacity:1;
    pointer-events:all;
    background: radial-gradient(ellipse at center, rgba(20,8,2,0.88) 0%, rgba(8,6,4,0.97) 100%);
  }

  .verse-ornament-top, .verse-ornament-bottom {
    width:1px;height:60px;
    background: linear-gradient(to bottom, transparent, rgba(255,150,50,0.5), transparent);
    margin:18px 0;
    opacity:0;
    transition: opacity 1.5s ease 0.8s, transform 1.5s ease 0.8s;
    transform:scaleY(0);
  }
  .verse-ornament-bottom {
    background: linear-gradient(to top, transparent, rgba(255,150,50,0.5), transparent);
    transition-delay:0.9s;
  }
  #verse-overlay.show .verse-ornament-top,
  #verse-overlay.show .verse-ornament-bottom {
    opacity:1; transform:scaleY(1);
  }

  .verse-ref {
    font-family:'Cinzel',serif; font-weight:300;
    font-size:11px;letter-spacing:8px;text-transform:uppercase;
    color:rgba(255,150,50,0.55);
    opacity:0;
    transition: opacity 1.5s ease 1.2s, transform 1.2s ease 1.2s;
    transform:translateY(10px);
    margin-bottom:28px;
  }
  #verse-overlay.show .verse-ref { opacity:1; transform:translateY(0); }

  .verse-line {
    font-family:'Cormorant Garamond',serif;
    font-weight:300;font-style:italic;
    font-size:clamp(17px,2.8vw,26px);
    color:rgba(255,230,180,0.92);
    text-align:center;
    max-width:620px;
    line-height:1.75;
    letter-spacing:0.5px;
    padding:0 40px;
    opacity:0;
    transition: opacity 2s ease 1.8s, transform 1.8s ease 1.8s;
    transform:translateY(18px);
    text-shadow:
      0 0 40px rgba(255,120,30,0.3),
      0 2px 20px rgba(0,0,0,0.8);
  }
  #verse-overlay.show .verse-line { opacity:1; transform:translateY(0); }

  .verse-close {
    margin-top:40px;
    font-family:'Cinzel',serif; font-weight:300;
    font-size:9px;letter-spacing:6px;text-transform:uppercase;
    color:rgba(255,140,50,0.35);
    cursor:pointer;
    border:none;background:transparent;
    opacity:0;
    transition: opacity 1s ease 3.5s, color 0.3s;
    pointer-events:none;
  }
  #verse-overlay.show .verse-close {
    opacity:1;pointer-events:all;
  }
  .verse-close:hover { color:rgba(255,170,80,0.7); }

  /* â”€â”€ WRITING PAPER OVERLAY â”€â”€ */
  #paper-overlay {
    position:fixed;inset:0;z-index:90;
    display:flex;align-items:center;justify-content:center;
    pointer-events:none;opacity:0;
    transition:opacity 0.8s cubic-bezier(0.4,0,0.2,1);
    background: radial-gradient(ellipse at 50% 60%, rgba(10,5,2,0.82) 0%, rgba(5,3,1,0.96) 100%);
  }
  #paper-overlay.show { opacity:1; pointer-events:all; }

  .paper-card {
    position:relative;
    width: min(520px, 90vw);
    background: linear-gradient(160deg,
      rgba(245,238,218,0.93) 0%,
      rgba(238,228,200,0.90) 40%,
      rgba(230,218,188,0.88) 100%);
    border-radius:1px;
    padding:48px 52px 40px;
    box-shadow:
      0 0 0 1px rgba(180,150,80,0.25),
      0 8px 60px rgba(0,0,0,0.7),
      0 2px 8px rgba(0,0,0,0.4),
      inset 0 1px 0 rgba(255,255,220,0.6);
    transform:translateY(24px) rotate(-0.4deg);
    transition: transform 0.8s cubic-bezier(0.4,0,0.2,1), opacity 0.8s ease;
    opacity:0;
  }
  #paper-overlay.show .paper-card {
    transform:translateY(0) rotate(-0.4deg);
    opacity:1;
    transition-delay:0.15s;
  }

  /* Paper texture lines */
  .paper-card::before {
    content:'';position:absolute;inset:0;pointer-events:none;
    background: repeating-linear-gradient(
      transparent, transparent 27px,
      rgba(160,140,100,0.12) 28px
    );
    top:76px;border-radius:1px;
  }

  /* Red margin line */
  .paper-card::after {
    content:'';position:absolute;
    left:72px;top:0;bottom:0;width:1px;
    background:rgba(200,80,80,0.25);
    pointer-events:none;
  }

  .paper-prompt {
    font-family:'Cormorant Garamond',serif;
    font-size:11px;font-weight:400;font-style:italic;
    letter-spacing:3px;text-transform:uppercase;
    color:rgba(100,70,30,0.55);
    margin-bottom:22px;
    padding-bottom:14px;
    border-bottom:1px solid rgba(160,130,80,0.2);
    line-height:1.6;
  }

  .paper-question {
    font-family:'Cormorant Garamond',serif;
    font-size:clamp(16px,2.2vw,21px);
    font-weight:300;
    color:rgba(60,38,14,0.82);
    line-height:1.65;
    margin-bottom:26px;
    letter-spacing:0.2px;
  }

  .paper-question em {
    font-style:italic;
    color:rgba(60,38,14,0.65);
  }

  #paper-text {
    width:100%;
    min-height:130px;
    max-height:220px;
    resize:none;
    background:transparent;
    border:none;outline:none;
    font-family:'Cormorant Garamond',serif;
    font-size:clamp(15px,1.9vw,18px);
    font-weight:400;
    color:rgba(40,24,8,0.88);
    line-height:28px; /* matches paper lines */
    letter-spacing:0.15px;
    caret-color:rgba(180,90,20,0.8);
    padding:0;
    overflow-y:auto;
  }
  #paper-text::placeholder {
    color:rgba(140,110,70,0.35);
    font-style:italic;
  }
  #paper-text::-webkit-scrollbar { width:3px; }
  #paper-text::-webkit-scrollbar-thumb { background:rgba(160,120,60,0.3); border-radius:2px; }

  .paper-footer {
    display:flex;align-items:center;justify-content:space-between;
    margin-top:28px;
    padding-top:16px;
    border-top:1px solid rgba(160,130,80,0.18);
  }

  .paper-char-count {
    font-family:'Cinzel',serif;font-size:9px;
    letter-spacing:3px;color:rgba(140,100,50,0.4);
  }

  #btn-throw {
    position:relative;
    background:transparent;border:none;cursor:pointer;
    padding:0;font-family:'Cinzel',serif;
    transition:opacity 0.3s;
  }
  #btn-throw:disabled { opacity:0.25;cursor:default;pointer-events:none; }

  .throw-inner {
    display:flex;align-items:center;gap:10px;
    padding:12px 28px;
    border:1px solid rgba(180,90,20,0.45);
    color:rgba(140,70,10,0.85);
    font-size:9px;letter-spacing:4.5px;text-transform:uppercase;
    font-family:'Cinzel',serif;font-weight:400;
    background:rgba(255,220,160,0.12);
    backdrop-filter:blur(4px);
    clip-path:polygon(8px 0%,100% 0%,calc(100% - 8px) 100%,0% 100%);
    transition:all 0.35s ease;
  }
  #btn-throw:hover .throw-inner {
    background:rgba(255,180,80,0.18);
    border-color:rgba(200,110,30,0.7);
    color:rgba(160,80,10,1);
    box-shadow:0 0 20px rgba(200,100,20,0.15);
  }
  #btn-throw:active .throw-inner { transform:scale(0.97); }

  .throw-icon { font-size:14px; transition:transform 0.4s ease; }
  #btn-throw:hover .throw-icon { transform:translateX(3px) rotate(8deg); }

  /* Corner ornaments on paper card */
  .paper-corner {
    position:absolute;width:10px;height:10px;
    border-color:rgba(160,120,60,0.35);border-style:solid;
  }
  .pc-tl { top:12px;left:12px;border-width:1px 0 0 1px; }
  .pc-tr { top:12px;right:12px;border-width:1px 1px 0 0; }
  .pc-bl { bottom:12px;left:12px;border-width:0 0 1px 1px; }
  .pc-br { bottom:12px;right:12px;border-width:0 1px 1px 0; }

  /* skip / close paper */
  #btn-skip-paper {
    position:absolute;top:14px;right:18px;
    background:transparent;border:none;cursor:pointer;
    font-family:'Cinzel',serif;font-size:8px;letter-spacing:3px;
    color:rgba(120,90,50,0.35);text-transform:uppercase;
    transition:color 0.3s;padding:4px 0;
  }
  #btn-skip-paper:hover { color:rgba(140,100,50,0.7); }
</style>
</head>
<body>
<div id="hint">Fogata Â· Salmo 51:10</div>

<!-- BUTTON -->
<div id="btn-wrap">
  <button id="btn-paper">
    <div class="btn-inner">
      <span class="btn-icon">ðŸ—’</span>
      <span>Escribir en el papel</span>
    </div>
  </button>
  <div class="btn-glow"></div>
</div>

<!-- WRITING PAPER OVERLAY -->
<div id="paper-overlay">
  <div class="paper-card">
    <div class="paper-corner pc-tl"></div>
    <div class="paper-corner pc-tr"></div>
    <div class="paper-corner pc-bl"></div>
    <div class="paper-corner pc-br"></div>
    <button id="btn-skip-paper" onclick="closePaperOverlay()">Ã— cerrar</button>
    <div class="paper-prompt">ReflexiÃ³n personal</div>
    <div class="paper-question">
      Escribe aquello que dejaste,<br>
      <em>pero que tu corazÃ³n todavÃ­a extraÃ±a.</em>
    </div>
    <textarea id="paper-text" maxlength="400" placeholder="Escribe aquÃ­ con tu corazÃ³n..."></textarea>
    <div class="paper-footer">
      <span class="paper-char-count" id="char-count">0 / 400</span>
      <button id="btn-throw" onclick="throwPaper()">
        <div class="throw-inner">
          <span class="throw-icon">ðŸ”¥</span>
          <span>Lanzar al fuego</span>
        </div>
      </button>
    </div>
  </div>
</div>

<!-- VERSE OVERLAY -->
<div id="verse-overlay">
  <div class="verse-ornament-top"></div>
  <div class="verse-ref">Salmo 51 Â· 10</div>
  <div class="verse-line">
    "Crea en mÃ­, oh Dios, un corazÃ³n limpio,<br>
    y renueva un espÃ­ritu recto dentro de mÃ­."
  </div>
  <div class="verse-ornament-bottom"></div>
  <button class="verse-close" onclick="closeVerse()">Â· cerrar Â·</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â”€â”€â”€ RENDERER / SCENE / CAMERA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.shadowMap.enabled=true;
renderer.shadowMap.type=THREE.PCFSoftShadowMap;
renderer.toneMapping=THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure=0.85;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x080604,0.07);

const camera = new THREE.PerspectiveCamera(55,innerWidth/innerHeight,0.1,200);
camera.position.set(0,3.2,7.5);
camera.lookAt(0,1.0,0);

// â”€â”€â”€ LIGHTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const fireLight = new THREE.PointLight(0xff6600,3.2,20,1.5);
fireLight.position.set(0,1.8,0); fireLight.castShadow=true;
fireLight.shadow.mapSize.set(512,512); scene.add(fireLight);
const fireLight2 = new THREE.PointLight(0xff2200,1.5,7,2);
fireLight2.position.set(0,0.8,0); scene.add(fireLight2);
scene.add(new THREE.AmbientLight(0x110e08,1));

// â”€â”€â”€ FLOOR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const floor = new THREE.Mesh(new THREE.CircleGeometry(15,64),
  new THREE.MeshStandardMaterial({ color:0x0e0b07,roughness:1 }));
floor.rotation.x=-Math.PI/2; floor.receiveShadow=true; scene.add(floor);

const dirt = new THREE.Mesh(new THREE.RingGeometry(1.55,2.9,48),
  new THREE.MeshStandardMaterial({ color:0x191208,roughness:1 }));
dirt.rotation.x=-Math.PI/2; dirt.position.y=0.001; scene.add(dirt);

// â”€â”€â”€ STONES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const stoneMat=new THREE.MeshStandardMaterial({ color:0x3a3530,roughness:0.95 });
for(let i=0;i<14;i++){
  const a=(i/14)*Math.PI*2+0.1, r=1.95+Math.random()*0.25;
  const s=new THREE.Mesh(new THREE.DodecahedronGeometry(0.28+Math.random()*0.18,0),stoneMat);
  s.position.set(Math.cos(a)*r,0.18+Math.random()*0.07,Math.sin(a)*r);
  s.rotation.set(Math.random()*3,Math.random()*6,Math.random()*3);
  s.castShadow=true; s.receiveShadow=true; scene.add(s);
}

// â”€â”€â”€ LOGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const woodMat=new THREE.MeshStandardMaterial({ color:0x3b1e0e,roughness:0.95 });
for(let i=0;i<3;i++){
  const log=new THREE.Mesh(new THREE.CylinderGeometry(0.13,0.17,2.8,12),woodMat);
  log.rotation.z=Math.PI/2; log.rotation.y=i*(Math.PI/3)+0.3;
  log.position.y=0.12+i*0.07; log.castShadow=true; scene.add(log);
}

// â”€â”€â”€ FIRE SHADER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FIRE_VERT=`
  uniform float time; uniform float phase; uniform float boost; varying vec2 vUv;
  float h(float n){ return fract(sin(n)*43758.5453); }
  float noise(vec2 p){ vec2 i=floor(p),f=fract(p); f=f*f*(3.-2.*f);
    return mix(mix(h(dot(i,vec2(1.,57.))),h(dot(i+vec2(1,0),vec2(1.,57.))),f.x),
               mix(h(dot(i+vec2(0,1),vec2(1.,57.))),h(dot(i+vec2(1,1),vec2(1.,57.))),f.x),f.y); }
  void main(){
    vUv=uv; float ny=vUv.y; float t=time+phase;
    float scaleX = 1.0 + boost * 0.65;
    float scaleY = 1.0 + boost * 0.90;
    vec3 pos = vec3(position.x * scaleX, position.y * scaleY, position.z);
    float sway=sin(t*3.2+ny*8.0)*(0.25+boost*0.15)*ny+sin(t*5.5+ny*4.5+phase)*0.13*ny;
    float turb=(noise(vec2(vUv.x*3.0+t*0.4,ny*5.0-t*2.8))-0.5)*(0.3+boost*0.2)*ny;
    vec4 mv=modelViewMatrix*vec4(0., pos.y, 0., 1.);
    mv.x += pos.x + sway + turb; gl_Position=projectionMatrix*mv;
  }`;
const FIRE_FRAG=`
  uniform float time; uniform float phase; uniform float boost; varying vec2 vUv;
  float h(float n){ return fract(sin(n)*43758.5453); }
  float noise(vec2 p){ vec2 i=floor(p),f=fract(p); f=f*f*(3.-2.*f);
    return mix(mix(h(dot(i,vec2(1.,57.))),h(dot(i+vec2(1,0),vec2(1.,57.))),f.x),
               mix(h(dot(i+vec2(0,1),vec2(1.,57.))),h(dot(i+vec2(1,1),vec2(1.,57.))),f.x),f.y); }
  void main(){
    float y=vUv.y,cx=abs(vUv.x-0.5)*2.,t=time+phase;
    float n1=noise(vec2(vUv.x*2.5,y*3.5-t*3.2));
    float n2=noise(vec2(vUv.x*5.0-.3,y*6.5-t*4.8));
    float alpha=(1.-y)*(1.-cx*cx)*(0.55+(n1*.5+n2*.3)*.9);
    alpha=smoothstep(0.,0.22,alpha);
    alpha = min(1.0, alpha * (1.0 + boost * 0.7));
    float heat=(1.-y)*(1.-cx*.75);
    heat = min(1.0, heat * (1.0 + boost * 0.5));
    vec3 col=mix(vec3(.85,.07,.0),vec3(1.,.50,.02),smoothstep(0.,.5,heat));
    col=mix(col,vec3(1.,.97,.65),smoothstep(.5,1.,heat));
    col = mix(col, vec3(1.,1.,1.0), boost * (1.-y) * (1.-cx*cx) * 0.65);
    gl_FragColor=vec4(col, alpha*.9);
  }`;

function makeFire(w,h,phase,yPos){
  const mat=new THREE.ShaderMaterial({
    transparent:true,depthWrite:false,side:THREE.DoubleSide,blending:THREE.AdditiveBlending,
    uniforms:{ time:{value:0}, phase:{value:phase}, boost:{value:0.0} },
    vertexShader:FIRE_VERT,fragmentShader:FIRE_FRAG
  });
  const mesh=new THREE.Mesh(new THREE.PlaneGeometry(w,h,28,28),mat);
  mesh.position.y=yPos; scene.add(mesh); return {mat,mesh};
}
const fires=[makeFire(1.8,3.2,0.0,1.7),makeFire(1.1,2.3,1.3,1.35),makeFire(0.7,1.5,2.7,1.0)];
const fireMats=fires.map(f=>f.mat);

// â”€â”€â”€ SMOKE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const smokeMat=new THREE.ShaderMaterial({
  transparent:true,depthWrite:false,side:THREE.DoubleSide, uniforms:{time:{value:0}},
  vertexShader:`uniform float time;varying vec2 vUv;
    float h(float n){return fract(sin(n)*43758.5453);}
    float noise(vec2 p){vec2 i=floor(p),f=fract(p);f=f*f*(3.-2.*f);
      return mix(mix(h(dot(i,vec2(1.,57.))),h(dot(i+vec2(1,0),vec2(1.,57.))),f.x),
                 mix(h(dot(i+vec2(0,1),vec2(1.,57.))),h(dot(i+vec2(1,1),vec2(1.,57.))),f.x),f.y);}
    void main(){vUv=uv;vec3 pos=position;
      float sway=(noise(vec2(pos.y*.4,time*.25))-.5)*vUv.y*1.4;
      vec4 mv=modelViewMatrix*vec4(0.,pos.y,0.,1.);mv.x+=pos.x+sway;gl_Position=projectionMatrix*mv;}`,
  fragmentShader:`varying vec2 vUv;
    void main(){float y=vUv.y,cx=abs(vUv.x-.5)*2.;
      float a=smoothstep(0.,.15,y)*(1.-y)*(1.-cx*cx)*.13;
      gl_FragColor=vec4(.22,.19,.16,a);}`
});
const smoke=new THREE.Mesh(new THREE.PlaneGeometry(4.5,6.,16,16),smokeMat);
smoke.position.y=6.2; scene.add(smoke);

// â”€â”€â”€ GROUND EMBERS (custom shader) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const EMBER_N = 130;
const ePos   = new Float32Array(EMBER_N*3);
const eCol   = new Float32Array(EMBER_N*3);
const eSize  = new Float32Array(EMBER_N);
const ePhase = new Float32Array(EMBER_N);
const eVelE  = new Float32Array(EMBER_N*2);
const eBase  = new Float32Array(EMBER_N*3);

function resetEmber(i){
  const a=Math.random()*Math.PI*2, r=0.15+Math.random()*1.5;
  const bx=Math.cos(a)*r, bz=Math.sin(a)*r;
  eBase[i*3]=bx; eBase[i*3+1]=0.02; eBase[i*3+2]=bz;
  ePos[i*3]=bx;  ePos[i*3+1]=0.02;  ePos[i*3+2]=bz;
  ePhase[i]=Math.random()*Math.PI*2;
  eVelE[i*2]=(Math.random()-.5)*0.006;
  eVelE[i*2+1]=(Math.random()-.5)*0.006;
  eSize[i]=0.0;
  const t=Math.random();
  eCol[i*3]=1; eCol[i*3+1]=0.2+t*0.5; eCol[i*3+2]=0;
}
for(let i=0;i<EMBER_N;i++) resetEmber(i);

const emberGeo2=new THREE.BufferGeometry();
emberGeo2.setAttribute('position', new THREE.Float32BufferAttribute(ePos,3));
emberGeo2.setAttribute('color',    new THREE.Float32BufferAttribute(eCol,3));
emberGeo2.setAttribute('aSize',    new THREE.Float32BufferAttribute(eSize,1));

const emberShaderMat = new THREE.ShaderMaterial({
  transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
  vertexColors:true,
  uniforms:{ pixelRatio:{ value: Math.min(devicePixelRatio,2) } },
  vertexShader:`
    attribute float aSize;
    varying vec3 vColor;
    uniform float pixelRatio;
    void main(){
      vColor = color;
      vec4 mv = modelViewMatrix * vec4(position,1.0);
      gl_PointSize = aSize * pixelRatio * (300.0 / -mv.z);
      gl_Position = projectionMatrix * mv;
    }
  `,
  fragmentShader:`
    varying vec3 vColor;
    void main(){
      float d = length(gl_PointCoord - 0.5);
      if(d > 0.5) discard;
      float a = smoothstep(0.5, 0.1, d);
      gl_FragColor = vec4(vColor, a);
    }
  `
});
scene.add(new THREE.Points(emberGeo2, emberShaderMat));

// â”€â”€â”€ SPARKS (animated, rise and fade) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SPARK_N = 380;
const sPos  = new Float32Array(SPARK_N*3);
const sVel  = new Float32Array(SPARK_N*3);
const sLife = new Float32Array(SPARK_N);
const sMaxLife = new Float32Array(SPARK_N);  // store original life for alpha fade
const sCol  = new Float32Array(SPARK_N*3);
const sSiz  = new Float32Array(SPARK_N);

function resetSpark(i, fromPaper=false, px=0, py=0, pz=0){
  if(fromPaper){
    sPos[i*3]=px+(Math.random()-.5)*.2;
    sPos[i*3+1]=py+.05;
    sPos[i*3+2]=pz+(Math.random()-.5)*.2;
    sVel[i*3]=(Math.random()-.5)*.03;
    sVel[i*3+1]=.03+Math.random()*.06;
    sVel[i*3+2]=(Math.random()-.5)*.03;
    sLife[i]=.7+Math.random()*.6;
  } else {
    const a=Math.random()*Math.PI*2, r=Math.random()*.3;
    sPos[i*3]=Math.cos(a)*r;
    sPos[i*3+1]=.5+Math.random()*.2;
    sPos[i*3+2]=Math.sin(a)*r;
    const sp=.010+Math.random()*.018, va=Math.random()*Math.PI*2;
    sVel[i*3]=Math.cos(va)*sp*.4;
    sVel[i*3+1]=.022+Math.random()*.038;
    sVel[i*3+2]=Math.sin(va)*sp*.4;
    sLife[i]=.8+Math.random()*.7;
  }
  sMaxLife[i] = sLife[i];
  const tc=Math.random();
  sCol[i*3]=1; sCol[i*3+1]=.3+tc*.5; sCol[i*3+2]=0;
  sSiz[i] = 0.04 + Math.random()*0.05;
}

for(let i=0;i<SPARK_N;i++){
  resetSpark(i);
  sPos[i*3+1]=Math.random()*3.0; // scatter initial heights
  sLife[i] = Math.random() * sMaxLife[i]; // randomize phase so not all die at once
}

const sparkGeo = new THREE.BufferGeometry();
const sparkPosAttr  = new THREE.BufferAttribute(sPos,3);
const sparkColAttr  = new THREE.BufferAttribute(sCol,3);
const sparkSizAttr  = new THREE.BufferAttribute(sSiz,1);
const sparkLifAttr  = new THREE.BufferAttribute(sLife,1);
const sparkMLifAttr = new THREE.BufferAttribute(sMaxLife,1);
sparkGeo.setAttribute('position', sparkPosAttr);
sparkGeo.setAttribute('color',    sparkColAttr);
sparkGeo.setAttribute('aSize',    sparkSizAttr);
sparkGeo.setAttribute('aLife',    sparkLifAttr);
sparkGeo.setAttribute('aMaxLife', sparkMLifAttr);

// Shader-based spark material â€” fades by life
const sparkMat = new THREE.ShaderMaterial({
  transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
  vertexColors:true,
  uniforms:{ pixelRatio:{ value: Math.min(devicePixelRatio,2) } },
  vertexShader:`
    attribute float aSize;
    attribute float aLife;
    attribute float aMaxLife;
    varying vec3 vColor;
    varying float vAlpha;
    uniform float pixelRatio;
    void main(){
      vColor = color;
      float lifeFrac = clamp(aLife / aMaxLife, 0.0, 1.0);
      // Fade in first 10%, fade out last 40%
      float fadeIn  = smoothstep(0.0, 0.1, lifeFrac);
      float fadeOut = smoothstep(0.0, 0.4, lifeFrac);
      vAlpha = fadeIn * fadeOut;
      vec4 mv = modelViewMatrix * vec4(position,1.0);
      float sz = aSize * (0.5 + lifeFrac*0.5);
      gl_PointSize = sz * pixelRatio * (400.0 / -mv.z);
      gl_Position = projectionMatrix * mv;
    }
  `,
  fragmentShader:`
    varying vec3 vColor;
    varying float vAlpha;
    void main(){
      float d = length(gl_PointCoord - 0.5);
      if(d > 0.5) discard;
      float a = smoothstep(0.5, 0.05, d) * vAlpha;
      gl_FragColor = vec4(vColor, a);
    }
  `
});
scene.add(new THREE.Points(sparkGeo, sparkMat));

// â”€â”€â”€ PAPER BURN SHADER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const PAPER_VERT=`
  uniform float burnProgress;
  varying vec2 vUv; varying vec3 vPos;
  float h(float n){ return fract(sin(n)*43758.5453); }
  float noise(vec2 p){ vec2 i=floor(p),f=fract(p);f=f*f*(3.-2.*f);
    return mix(mix(h(dot(i,vec2(1.,57.))),h(dot(i+vec2(1,0),vec2(1.,57.))),f.x),
               mix(h(dot(i+vec2(0,1),vec2(1.,57.))),h(dot(i+vec2(1,1),vec2(1.,57.))),f.x),f.y);}
  void main(){
    vUv=uv; vPos=position;
    vec3 pos=position;
    float edgeDist=min(abs(uv.x-.5)*2., abs(uv.y-.5)*2.);
    float curl=burnProgress * edgeDist * edgeDist * 0.35;
    pos.z += curl;
    pos.xy *= (1.0 - burnProgress * edgeDist * 0.25);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.);
  }`;
const PAPER_FRAG=`
  uniform float burnProgress; uniform float time;
  varying vec2 vUv; varying vec3 vPos;
  float h(float n){ return fract(sin(n)*43758.5453); }
  float noise(vec2 p){ vec2 i=floor(p),f=fract(p);f=f*f*(3.-2.*f);
    return mix(mix(h(dot(i,vec2(1.,57.))),h(dot(i+vec2(1,0),vec2(1.,57.))),f.x),
               mix(h(dot(i+vec2(0,1),vec2(1.,57.))),h(dot(i+vec2(1,1),vec2(1.,57.))),f.x),f.y);}
  float fbm(vec2 p){ return noise(p)*.5+noise(p*2.1)*.25+noise(p*4.2)*.125; }
  void main(){
    float edgeDist = min(min(vUv.x, 1.-vUv.x), min(vUv.y, 1.-vUv.y));
    float nv = fbm(vUv*4.5 + time*0.3) * 0.35;
    float burnMask = edgeDist + nv;
    float burnFront = burnProgress * 0.75;
    if(burnMask < burnFront - 0.05) discard;
    vec3 paperColor = vec3(0.85, 0.82, 0.70);
    vec3 burnColor  = vec3(1.0, 0.45, 0.02);
    vec3 charColor  = vec3(0.08, 0.06, 0.04);
    float glowWidth = 0.06 + nv*0.06;
    float onFront   = smoothstep(burnFront, burnFront+glowWidth, burnMask);
    vec3 col = mix(charColor, burnColor, onFront);
    col = mix(col, paperColor, smoothstep(burnFront+glowWidth, burnFront+glowWidth+0.05, burnMask));
    float heat = smoothstep(burnFront+0.1, burnFront+0.3, burnMask);
    col = mix(col * vec3(1.,0.9,.6), col, heat);
    float alpha = smoothstep(burnFront-0.05, burnFront, burnMask);
    alpha *= 1.0 - smoothstep(0.85, 1.0, burnProgress);
    gl_FragColor = vec4(col, alpha);
  }`;

// â”€â”€â”€ PAPER THROW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const papers = [];
let paperBurnedCount = 0;

function createPaper(){
  const geo = new THREE.PlaneGeometry(0.55, 0.70, 14, 16);
  const pa = geo.attributes.position;
  for(let i=0;i<pa.count;i++){
    pa.setX(i, pa.getX(i)+(Math.random()-.5)*.05);
    pa.setY(i, pa.getY(i)+(Math.random()-.5)*.05);
    pa.setZ(i, (Math.random()-.5)*.10);
  }
  pa.needsUpdate=true; geo.computeVertexNormals();

  const mat = new THREE.ShaderMaterial({
    transparent:true, side:THREE.DoubleSide, depthWrite:false,
    uniforms:{ burnProgress:{value:0.0}, time:{value:0.0} },
    vertexShader:PAPER_VERT, fragmentShader:PAPER_FRAG
  });

  const mesh = new THREE.Mesh(geo,mat);
  const side = Math.random()<.5 ? -1 : 1;
  const startX = side*(5.5+Math.random()*1.0);
  const startY = 2.2+Math.random()*1.0;
  const startZ = (Math.random()-.5)*1.5;
  mesh.position.set(startX,startY,startZ);
  mesh.rotation.set(Math.random()*2,Math.random()*6,Math.random()*2);
  scene.add(mesh);

  const endX = (Math.random()-.5)*.35;
  const endY = 0.35 + Math.random()*.2;
  const endZ = (Math.random()-.5)*.35;
  const flightTime = 1.4 + Math.random()*.4;

  papers.push({
    mesh, mat, geo,
    startPos: new THREE.Vector3(startX,startY,startZ),
    endPos: new THREE.Vector3(endX,endY,endZ),
    flightTime, elapsed:0,
    arcHeight: 1.5 + Math.random()*.8,
    rotVel: new THREE.Vector3((Math.random()-.5)*.18,(Math.random()-.5)*.18,(Math.random()-.5)*.14),
    state: 'flying',
    burnProgress:0,
    localTime:0
  });
}

function updatePapers(dt){
  for(const p of papers){
    if(p.state==='done') continue;
    p.localTime += dt;
    p.mat.uniforms.time.value = p.localTime;

    if(p.state==='flying'){
      p.elapsed += dt;
      const t = Math.min(p.elapsed / p.flightTime, 1.0);
      const ex = p.startPos.x + (p.endPos.x - p.startPos.x)*t;
      const ez = p.startPos.z + (p.endPos.z - p.startPos.z)*t;
      const baseY = p.startPos.y + (p.endPos.y - p.startPos.y)*t;
      const ey = baseY + Math.sin(t*Math.PI)*p.arcHeight;
      p.mesh.position.set(ex,ey,ez);
      p.mesh.rotation.x += p.rotVel.x;
      p.mesh.rotation.y += p.rotVel.y;
      p.mesh.rotation.z += p.rotVel.z;

      if(t >= 1.0){
        p.state='landing';
        p.mesh.position.copy(p.endPos);
        p.mesh.rotation.x = -Math.PI/2 + (Math.random()-.5)*.4;
        p.mesh.rotation.y = Math.random()*Math.PI*2;
        p.mesh.rotation.z = (Math.random()-.5)*.3;
        // Immediately start burning with eased boost ramp
        p.state='burning';
        p.boostRamp = 0; // will ease from 0â†’1 over ~0.5s
      }

    } else if(p.state==='burning'){
      // Ease-in the fire boost on first frames of burning
      if(p.boostRamp !== undefined && p.boostRamp < 1.0){
        p.boostRamp = Math.min(1.0, p.boostRamp + dt * 2.2); // ~0.45s to full
        // Cubic ease-in-out
        const eased = p.boostRamp < 0.5
          ? 4*p.boostRamp*p.boostRamp*p.boostRamp
          : 1 - Math.pow(-2*p.boostRamp+2,3)/2;
        fireBoost = Math.min(2.5, fireBoost + eased * 0.08);
      }
      // SLOWER burn: was 0.003, now 0.0014
      p.burnProgress += 0.0022 + Math.random()*0.0008;
      p.mat.uniforms.burnProgress.value = p.burnProgress;
      p.mesh.position.y += 0.0005;
      p.mesh.rotation.z += Math.sin(p.localTime*3)*.001;

      // More frequent sparks from burning paper
      if(p.burnProgress<0.9 && Math.random()<0.28){
        const si=Math.floor(Math.random()*SPARK_N);
        const px=p.mesh.position.x, py=p.mesh.position.y, pz=p.mesh.position.z;
        resetSpark(si, true, px, py, pz);
      }

      if(p.burnProgress>=1.0){
        scene.remove(p.mesh);
        p.geo.dispose(); p.mat.dispose();
        p.state='done';
        paperBurnedCount++;
        // Show verse after every paper burns
        setTimeout(showVerse, 400);
      }
    }
  }
}

// â”€â”€â”€ VERSE LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function showVerse(){
  const overlay = document.getElementById('verse-overlay');
  // Reset to allow re-animation
  overlay.classList.remove('show');
  void overlay.offsetWidth; // force reflow
  overlay.classList.add('show');
}
function closeVerse(){
  const overlay = document.getElementById('verse-overlay');
  overlay.style.transition='opacity 1.5s ease';
  overlay.style.opacity='0';
  setTimeout(()=>{ overlay.classList.remove('show'); overlay.style.opacity=''; overlay.style.transition=''; },1600);
}

// â”€â”€â”€ PAPER OVERLAY LOGIC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openPaperOverlay(){
  const overlay = document.getElementById('paper-overlay');
  overlay.classList.add('show');
  setTimeout(()=>{ document.getElementById('paper-text').focus(); }, 400);
}
function closePaperOverlay(){
  const overlay = document.getElementById('paper-overlay');
  overlay.classList.remove('show');
  document.getElementById('paper-text').value='';
  document.getElementById('char-count').textContent='0 / 400';
}
function throwPaper(){
  closePaperOverlay();
  setTimeout(()=>{ createPaper(); }, 300);
}

// Char counter
document.getElementById('paper-text').addEventListener('input', function(){
  document.getElementById('char-count').textContent = this.value.length + ' / 400';
});

// â”€â”€â”€ BUTTON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('btn-paper').addEventListener('click',function(){
  openPaperOverlay();
});

// â”€â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let clock=0;
let fireBoost = 0;
const _clock = new THREE.Clock();

function animate(){
  requestAnimationFrame(animate);
  const dt = _clock.getDelta();
  clock += dt;

  // Decay fire boost â€” slightly slower decay for more dramatic sustain
  fireBoost *= 0.988;

  fireMats.forEach(m=>{ m.uniforms.time.value=clock; m.uniforms.boost.value=fireBoost; });
  smokeMat.uniforms.time.value=clock;

  // â”€â”€ UPDATE SPARKS (rise + fade by life) â”€â”€
  for(let i=0;i<SPARK_N;i++){
    sLife[i] -= .009+Math.random()*.005;
    sPos[i*3]   += sVel[i*3]   + (Math.random()-.5)*.006;
    sPos[i*3+1] += sVel[i*3+1];
    sPos[i*3+2] += sVel[i*3+2] + (Math.random()-.5)*.006;
    sVel[i*3+1] *= 0.990; // decelerate upward
    const lifeFrac = Math.max(0, sLife[i]/Math.max(0.001,sMaxLife[i]));
    sCol[i*3]   = 1.0;
    sCol[i*3+1] = Math.max(0, 0.5 * lifeFrac);
    sCol[i*3+2] = 0.0;
    if(sLife[i]<=0 || sPos[i*3+1]>6.5) resetSpark(i);
  }
  sparkPosAttr.needsUpdate=true;
  sparkColAttr.needsUpdate=true;
  sparkSizAttr.needsUpdate=true;
  sparkLifAttr.needsUpdate=true;
  sparkMLifAttr.needsUpdate=true;

  // â”€â”€ GROUND EMBERS â”€â”€
  for(let i=0;i<EMBER_N;i++){
    ePhase[i] += 0.05 + Math.random()*0.04;
    const pulse  = 0.5 + 0.5*Math.sin(ePhase[i]);
    const pulse2 = 0.5 + 0.5*Math.sin(ePhase[i]*1.7 + 1.3);
    eBase[i*3]   += eVelE[i*2];
    eBase[i*3+2] += eVelE[i*2+1];
    const dx=eBase[i*3], dz=eBase[i*3+2];
    if(Math.sqrt(dx*dx+dz*dz) > 1.7){ eVelE[i*2]*=-1; eVelE[i*2+1]*=-1; }
    ePos[i*3]   = eBase[i*3]   + (Math.random()-.5)*0.04;
    ePos[i*3+1] = 0.02 + pulse*0.06;
    ePos[i*3+2] = eBase[i*3+2] + (Math.random()-.5)*0.04;
    eSize[i] = (0.5 + pulse*1.8 + pulse2*0.6) * (1.0 + fireBoost*2.5);
    const heat = pulse * (1.0 + fireBoost * 2.0);
    eCol[i*3]   = Math.min(1.0, 0.6 + heat*0.4);
    eCol[i*3+1] = Math.min(1.0, heat*0.55);
    eCol[i*3+2] = Math.min(1.0, Math.max(0, heat*0.15 - 0.1));

    if(fireBoost>0.25 && Math.random()<fireBoost*0.06){
      const si=Math.floor(Math.random()*SPARK_N);
      sPos[si*3]=ePos[i*3]; sPos[si*3+1]=0.08; sPos[si*3+2]=ePos[i*3+2];
      sVel[si*3]=(Math.random()-.5)*.04;
      sVel[si*3+1]=.07+Math.random()*.1;
      sVel[si*3+2]=(Math.random()-.5)*.04;
      sLife[si]=.4+Math.random()*.5;
      sMaxLife[si]=sLife[si];
    }
  }
  emberGeo2.attributes.position.needsUpdate=true;
  emberGeo2.attributes.color.needsUpdate=true;
  emberGeo2.attributes.aSize.needsUpdate=true;

  // â”€â”€ FIRE LIGHT FLICKER + BOOST â”€â”€
  const flk=Math.sin(clock*9.1)*.18+Math.sin(clock*13.7)*.1+Math.sin(clock*6.3)*.07;
  fireLight.intensity   = 2.9 + flk + fireBoost*5.5;
  fireLight2.intensity  = 1.3 + flk*.6 + fireBoost*3.0;
  fireLight.color.setHSL(.07+Math.sin(clock*4.3)*.015, 1, Math.min(0.72,.56+fireBoost*.18));

  updatePapers(dt);
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
