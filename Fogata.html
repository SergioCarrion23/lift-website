<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Fogata 3D</title>
<style>
  * { margin:0;padding:0;box-sizing:border-box; }
  body { overflow:hidden; background:#080604; font-family:'Georgia',serif; }
  #btn-wrap { position:fixed;bottom:40px;left:50%;transform:translateX(-50%);z-index:10; }
  #btn-paper {
    padding:14px 38px; background:transparent;
    border:1.5px solid rgba(255,150,30,0.55); color:#ffb84d;
    font-size:14px; letter-spacing:3.5px; text-transform:uppercase;
    cursor:pointer; transition:all 0.3s; backdrop-filter:blur(8px);
    font-family:'Georgia',serif;
  }
  #btn-paper:hover { background:rgba(255,120,0,0.12); border-color:#ffaa33; box-shadow:0 0 24px rgba(255,100,0,0.35); color:#ffd580; }
  #btn-paper:active { transform:scale(0.96); }
  #btn-paper:disabled { opacity:0.25; cursor:default; pointer-events:none; }
  #hint { position:fixed;top:28px;left:50%;transform:translateX(-50%); color:rgba(255,130,30,0.28); font-size:11px;letter-spacing:5px;text-transform:uppercase;user-select:none; }
</style>
</head>
<body>
<div id="hint">Fogata Â· Three.js</div>
<div id="btn-wrap"><button id="btn-paper">ðŸ—’ Lanzar papel</button></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// â”€â”€â”€ RENDERER / SCENE / CAMERA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth,innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.shadowMap.enabled=true;
renderer.shadowMap.type=THREE.PCFSoftShadowMap;
renderer.toneMapping=THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure=0.85;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x080604,0.07);

const camera = new THREE.PerspectiveCamera(55,innerWidth/innerHeight,0.1,200);
camera.position.set(0,3.2,7.5);
camera.lookAt(0,1.0,0);

// â”€â”€â”€ LIGHTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const fireLight = new THREE.PointLight(0xff6600,3.2,20,1.5);
fireLight.position.set(0,1.8,0); fireLight.castShadow=true;
fireLight.shadow.mapSize.set(512,512); scene.add(fireLight);
const fireLight2 = new THREE.PointLight(0xff2200,1.5,7,2);
fireLight2.position.set(0,0.8,0); scene.add(fireLight2);
scene.add(new THREE.AmbientLight(0x110e08,1));

// â”€â”€â”€ FLOOR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const floor = new THREE.Mesh(new THREE.CircleGeometry(15,64),
  new THREE.MeshStandardMaterial({ color:0x0e0b07,roughness:1 }));
floor.rotation.x=-Math.PI/2; floor.receiveShadow=true; scene.add(floor);

const dirt = new THREE.Mesh(new THREE.RingGeometry(1.55,2.9,48),
  new THREE.MeshStandardMaterial({ color:0x191208,roughness:1 }));
dirt.rotation.x=-Math.PI/2; dirt.position.y=0.001; scene.add(dirt);

// â”€â”€â”€ STONES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const stoneMat=new THREE.MeshStandardMaterial({ color:0x3a3530,roughness:0.95 });
for(let i=0;i<14;i++){
  const a=(i/14)*Math.PI*2+0.1, r=1.95+Math.random()*0.25;
  const s=new THREE.Mesh(new THREE.DodecahedronGeometry(0.28+Math.random()*0.18,0),stoneMat);
  s.position.set(Math.cos(a)*r,0.18+Math.random()*0.07,Math.sin(a)*r);
  s.rotation.set(Math.random()*3,Math.random()*6,Math.random()*3);
  s.castShadow=true; s.receiveShadow=true; scene.add(s);
}

// â”€â”€â”€ LOGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const woodMat=new THREE.MeshStandardMaterial({ color:0x3b1e0e,roughness:0.95 });
for(let i=0;i<3;i++){
  const log=new THREE.Mesh(new THREE.CylinderGeometry(0.13,0.17,2.8,12),woodMat);
  log.rotation.z=Math.PI/2; log.rotation.y=i*(Math.PI/3)+0.3;
  log.position.y=0.12+i*0.07; log.castShadow=true; scene.add(log);
}

// â”€â”€â”€ FIRE SHADER (billboard) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FIRE_VERT=`
  uniform float time; uniform float phase; uniform float boost; varying vec2 vUv;
  float h(float n){ return fract(sin(n)*43758.5453); }
  float noise(vec2 p){ vec2 i=floor(p),f=fract(p); f=f*f*(3.-2.*f);
    return mix(mix(h(dot(i,vec2(1.,57.))),h(dot(i+vec2(1,0),vec2(1.,57.))),f.x),
               mix(h(dot(i+vec2(0,1),vec2(1.,57.))),h(dot(i+vec2(1,1),vec2(1.,57.))),f.x),f.y); }
  void main(){
    vUv=uv; float ny=vUv.y; float t=time+phase;
    // Scale the plane itself by boost â€” this is what actually grows the flame
    float scaleX = 1.0 + boost * 0.55;
    float scaleY = 1.0 + boost * 0.75;
    vec3 pos = vec3(position.x * scaleX, position.y * scaleY, position.z);
    float sway=sin(t*3.2+ny*8.0)*(0.25+boost*0.15)*ny+sin(t*5.5+ny*4.5+phase)*0.13*ny;
    float turb=(noise(vec2(vUv.x*3.0+t*0.4,ny*5.0-t*2.8))-0.5)*(0.3+boost*0.2)*ny;
    vec4 mv=modelViewMatrix*vec4(0., pos.y, 0., 1.);
    mv.x += pos.x + sway + turb; gl_Position=projectionMatrix*mv;
  }`;
const FIRE_FRAG=`
  uniform float time; uniform float phase; uniform float boost; varying vec2 vUv;
  float h(float n){ return fract(sin(n)*43758.5453); }
  float noise(vec2 p){ vec2 i=floor(p),f=fract(p); f=f*f*(3.-2.*f);
    return mix(mix(h(dot(i,vec2(1.,57.))),h(dot(i+vec2(1,0),vec2(1.,57.))),f.x),
               mix(h(dot(i+vec2(0,1),vec2(1.,57.))),h(dot(i+vec2(1,1),vec2(1.,57.))),f.x),f.y); }
  void main(){
    float y=vUv.y,cx=abs(vUv.x-0.5)*2.,t=time+phase;
    float n1=noise(vec2(vUv.x*2.5,y*3.5-t*3.2));
    float n2=noise(vec2(vUv.x*5.0-.3,y*6.5-t*4.8));
    float alpha=(1.-y)*(1.-cx*cx)*(0.55+(n1*.5+n2*.3)*.9);
    alpha=smoothstep(0.,0.22,alpha);
    // Boost: more opaque, wider color spread, hotter core
    alpha = min(1.0, alpha * (1.0 + boost * 0.6));
    float heat=(1.-y)*(1.-cx*.75);
    heat = min(1.0, heat * (1.0 + boost * 0.4));
    vec3 col=mix(vec3(.85,.07,.0),vec3(1.,.50,.02),smoothstep(0.,.5,heat));
    col=mix(col,vec3(1.,.97,.65),smoothstep(.5,1.,heat));
    // Extra white-hot core when boosted
    col = mix(col, vec3(1.,1.,0.9), boost * (1.-y) * (1.-cx*cx) * 0.5);
    gl_FragColor=vec4(col, alpha*.9);
  }`;

function makeFire(w,h,phase,yPos){
  const mat=new THREE.ShaderMaterial({
    transparent:true,depthWrite:false,side:THREE.DoubleSide,blending:THREE.AdditiveBlending,
    uniforms:{ time:{value:0}, phase:{value:phase}, boost:{value:0.0} },
    vertexShader:FIRE_VERT,fragmentShader:FIRE_FRAG
  });
  const mesh=new THREE.Mesh(new THREE.PlaneGeometry(w,h,28,28),mat);
  mesh.position.y=yPos; scene.add(mesh); return {mat,mesh};
}
const fires=[makeFire(1.8,3.2,0.0,1.7),makeFire(1.1,2.3,1.3,1.35),makeFire(0.7,1.5,2.7,1.0)];
const fireMats=fires.map(f=>f.mat);
const fireMeshes=fires.map(f=>f.mesh);

// â”€â”€â”€ SMOKE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const smokeMat=new THREE.ShaderMaterial({
  transparent:true,depthWrite:false,side:THREE.DoubleSide, uniforms:{time:{value:0}},
  vertexShader:`uniform float time;varying vec2 vUv;
    float h(float n){return fract(sin(n)*43758.5453);}
    float noise(vec2 p){vec2 i=floor(p),f=fract(p);f=f*f*(3.-2.*f);
      return mix(mix(h(dot(i,vec2(1.,57.))),h(dot(i+vec2(1,0),vec2(1.,57.))),f.x),
                 mix(h(dot(i+vec2(0,1),vec2(1.,57.))),h(dot(i+vec2(1,1),vec2(1.,57.))),f.x),f.y);}
    void main(){vUv=uv;vec3 pos=position;
      float sway=(noise(vec2(pos.y*.4,time*.25))-.5)*vUv.y*1.4;
      vec4 mv=modelViewMatrix*vec4(0.,pos.y,0.,1.);mv.x+=pos.x+sway;gl_Position=projectionMatrix*mv;}`,
  fragmentShader:`varying vec2 vUv;
    void main(){float y=vUv.y,cx=abs(vUv.x-.5)*2.;
      float a=smoothstep(0.,.15,y)*(1.-y)*(1.-cx*cx)*.13;
      gl_FragColor=vec4(.22,.19,.16,a);}`
});
const smoke=new THREE.Mesh(new THREE.PlaneGeometry(4.5,6.,16,16),smokeMat);
smoke.position.y=6.2; scene.add(smoke);

// â”€â”€â”€ DYNAMIC GROUND EMBERS (custom shader â€” per-point size pulsing) â”€â”€â”€â”€â”€â”€â”€â”€
const EMBER_N = 130;
const ePos   = new Float32Array(EMBER_N*3);
const eCol   = new Float32Array(EMBER_N*3);
const eSize  = new Float32Array(EMBER_N);     // per-point size
const ePhase = new Float32Array(EMBER_N);     // individual pulse phase
const eVelE  = new Float32Array(EMBER_N*2);   // ground drift x,z
const eBase  = new Float32Array(EMBER_N*3);   // anchor position

function resetEmber(i){
  const a=Math.random()*Math.PI*2, r=0.15+Math.random()*1.5;
  const bx=Math.cos(a)*r, bz=Math.sin(a)*r;
  eBase[i*3]=bx; eBase[i*3+1]=0.02; eBase[i*3+2]=bz;
  ePos[i*3]=bx;  ePos[i*3+1]=0.02;  ePos[i*3+2]=bz;
  ePhase[i]=Math.random()*Math.PI*2;
  eVelE[i*2]=(Math.random()-.5)*0.006;
  eVelE[i*2+1]=(Math.random()-.5)*0.006;
  eSize[i]=0.0;
  const t=Math.random();
  eCol[i*3]=1; eCol[i*3+1]=0.2+t*0.5; eCol[i*3+2]=0;
}
for(let i=0;i<EMBER_N;i++) resetEmber(i);

const emberGeo2=new THREE.BufferGeometry();
emberGeo2.setAttribute('position', new THREE.Float32BufferAttribute(ePos,3));
emberGeo2.setAttribute('color',    new THREE.Float32BufferAttribute(eCol,3));
emberGeo2.setAttribute('aSize',    new THREE.Float32BufferAttribute(eSize,1));

const emberShaderMat = new THREE.ShaderMaterial({
  transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
  vertexColors:true,
  uniforms:{ pixelRatio:{ value: Math.min(devicePixelRatio,2) } },
  vertexShader:`
    attribute float aSize;
    varying vec3 vColor;
    uniform float pixelRatio;
    void main(){
      vColor = color;
      vec4 mv = modelViewMatrix * vec4(position,1.0);
      gl_PointSize = aSize * pixelRatio * (300.0 / -mv.z);
      gl_Position = projectionMatrix * mv;
    }
  `,
  fragmentShader:`
    varying vec3 vColor;
    void main(){
      float d = length(gl_PointCoord - 0.5);
      if(d > 0.5) discard;
      float a = smoothstep(0.5, 0.1, d);
      gl_FragColor = vec4(vColor, a);
    }
  `
});
scene.add(new THREE.Points(emberGeo2, emberShaderMat));



// â”€â”€â”€ PAPER BURN SHADER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// The paper has its own ShaderMaterial so we can show a burn front spreading
const PAPER_VERT=`
  uniform float burnProgress; // 0=intact, 1=gone
  varying vec2 vUv;
  varying vec3 vPos;

  float h(float n){ return fract(sin(n)*43758.5453); }
  float noise(vec2 p){ vec2 i=floor(p),f=fract(p);f=f*f*(3.-2.*f);
    return mix(mix(h(dot(i,vec2(1.,57.))),h(dot(i+vec2(1,0),vec2(1.,57.))),f.x),
               mix(h(dot(i+vec2(0,1),vec2(1.,57.))),h(dot(i+vec2(1,1),vec2(1.,57.))),f.x),f.y);}

  void main(){
    vUv=uv; vPos=position;

    // Curl upward as it burns: edges lift
    vec3 pos=position;
    float edgeDist=min(abs(uv.x-.5)*2., abs(uv.y-.5)*2.); // 0=center,1=edge
    float curl=burnProgress * edgeDist * edgeDist * 0.35;
    pos.z += curl;
    // Slight vertical shrink toward center as it curls
    pos.xy *= (1.0 - burnProgress * edgeDist * 0.25);

    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.);
  }
`;
const PAPER_FRAG=`
  uniform float burnProgress;
  uniform float time;
  varying vec2 vUv;
  varying vec3 vPos;

  float h(float n){ return fract(sin(n)*43758.5453); }
  float noise(vec2 p){ vec2 i=floor(p),f=fract(p);f=f*f*(3.-2.*f);
    return mix(mix(h(dot(i,vec2(1.,57.))),h(dot(i+vec2(1,0),vec2(1.,57.))),f.x),
               mix(h(dot(i+vec2(0,1),vec2(1.,57.))),h(dot(i+vec2(1,1),vec2(1.,57.))),f.x),f.y);}
  float fbm(vec2 p){ return noise(p)*.5+noise(p*2.1)*.25+noise(p*4.2)*.125; }

  void main(){
    // Burn mask: noisy spread from outside edges inward
    float edgeDist = min(min(vUv.x, 1.-vUv.x), min(vUv.y, 1.-vUv.y));

    // Add turbulence to burn front
    float nv = fbm(vUv*4.5 + time*0.3) * 0.35;

    // Effective burn: edges burn first, center last
    // burnProgress 0->1: burn front sweeps inward
    float burnMask = edgeDist + nv;
    float burnFront = burnProgress * 0.75; // scaled so center burns near end

    // Discard (ash away) when burned
    if(burnMask < burnFront - 0.05) discard;

    // Colors
    vec3 paperColor = vec3(0.85, 0.82, 0.70); // off-white paper
    vec3 burnColor  = vec3(1.0, 0.45, 0.02);  // glowing orange edge
    vec3 charColor  = vec3(0.08, 0.06, 0.04); // black char

    // Zone near burn front glows
    float glowWidth = 0.06 + nv*0.06;
    float onFront   = smoothstep(burnFront, burnFront+glowWidth, burnMask);
    float justChar  = smoothstep(burnFront-0.02, burnFront+0.01, burnMask);

    vec3 col = mix(charColor, burnColor, onFront);
    col = mix(col, paperColor, smoothstep(burnFront+glowWidth, burnFront+glowWidth+0.05, burnMask));

    // Paper yellows slightly near heat
    float heat = smoothstep(burnFront+0.1, burnFront+0.3, burnMask);
    col = mix(col * vec3(1.,0.9,.6), col, heat);

    // Alpha: discard char zone slowly (ash floats away)
    float alpha = smoothstep(burnFront-0.05, burnFront, burnMask);
    alpha *= 1.0 - smoothstep(0.85, 1.0, burnProgress); // fade whole paper at very end

    gl_FragColor = vec4(col, alpha);
  }
`;

// â”€â”€â”€ PAPER THROW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const papers = [];

function createPaper(){
  const geo = new THREE.PlaneGeometry(0.55, 0.70, 14, 16);
  // Crumple geometry
  const pa = geo.attributes.position;
  for(let i=0;i<pa.count;i++){
    pa.setX(i, pa.getX(i)+(Math.random()-.5)*.05);
    pa.setY(i, pa.getY(i)+(Math.random()-.5)*.05);
    pa.setZ(i, (Math.random()-.5)*.10);
  }
  pa.needsUpdate=true; geo.computeVertexNormals();

  const mat = new THREE.ShaderMaterial({
    transparent:true, side:THREE.DoubleSide, depthWrite:false,
    uniforms:{ burnProgress:{value:0.0}, time:{value:0.0} },
    vertexShader:PAPER_VERT, fragmentShader:PAPER_FRAG
  });

  const mesh = new THREE.Mesh(geo,mat);

  // Start position: from a random side at roughly hand-throw height
  const side = Math.random()<.5 ? -1 : 1;
  const startX = side*(5.5+Math.random()*1.0);
  const startY = 2.2+Math.random()*1.0;
  const startZ = (Math.random()-.5)*1.5;
  mesh.position.set(startX,startY,startZ);
  mesh.rotation.set(Math.random()*2,Math.random()*6,Math.random()*2);
  scene.add(mesh);

  // Parabolic arc toward fire pit center
  const endX = (Math.random()-.5)*.35;
  const endY = 0.35 + Math.random()*.2; // lands ON the logs
  const endZ = (Math.random()-.5)*.35;

  const flightTime = 1.4 + Math.random()*.4; // seconds to reach fire

  papers.push({
    mesh, mat, geo,
    startPos: new THREE.Vector3(startX,startY,startZ),
    endPos: new THREE.Vector3(endX,endY,endZ),
    flightTime, elapsed:0,
    arcHeight: 1.5 + Math.random()*.8,
    rotStart: new THREE.Euler(mesh.rotation.x,mesh.rotation.y,mesh.rotation.z,'XYZ'),
    rotVel: new THREE.Vector3((Math.random()-.5)*.18,(Math.random()-.5)*.18,(Math.random()-.5)*.14),
    state: 'flying',   // flying | landing | burning
    burnProgress:0,
    localTime:0
  });
}

function updatePapers(dt){
  for(const p of papers){
    if(p.state==='done') continue;
    p.localTime += dt;
    p.mat.uniforms.time.value = p.localTime;

    if(p.state==='flying'){
      p.elapsed += dt;
      const t = Math.min(p.elapsed / p.flightTime, 1.0);

      // Smooth parabolic arc via lerp + sin arc
      const ex = p.startPos.x + (p.endPos.x - p.startPos.x)*t;
      const ez = p.startPos.z + (p.endPos.z - p.startPos.z)*t;
      const baseY = p.startPos.y + (p.endPos.y - p.startPos.y)*t;
      const ey = baseY + Math.sin(t*Math.PI)*p.arcHeight;

      p.mesh.position.set(ex,ey,ez);

      // Tumble during flight
      p.mesh.rotation.x += p.rotVel.x;
      p.mesh.rotation.y += p.rotVel.y;
      p.mesh.rotation.z += p.rotVel.z;

      if(t >= 1.0){
        p.state='landing';
        // Lay flat-ish on logs: slight random tilt
        p.mesh.position.copy(p.endPos);
        p.mesh.rotation.x = -Math.PI/2 + (Math.random()-.5)*.4;
        p.mesh.rotation.y = Math.random()*Math.PI*2;
        p.mesh.rotation.z = (Math.random()-.5)*.3;
        // Tiny bounce settle, then ignite
        setTimeout(()=>{
          p.state='burning';
          fireBoost = Math.max(fireBoost, 1.0); // spike fire intensity
        },300);
      }

    } else if(p.state==='burning'){
      // Slow burn over ~5 seconds
      p.burnProgress += 0.003;
      p.mat.uniforms.burnProgress.value = p.burnProgress;

      // Slight settle/shift as it burns
      p.mesh.position.y += 0.0005;
      p.mesh.rotation.z += Math.sin(p.localTime*3)*.001;

      // Emit sparks from burning paper
      if(p.burnProgress<0.9 && Math.random()<0.2){
        const si=Math.floor(Math.random()*SPARK_N);
        const px=p.mesh.position.x,py=p.mesh.position.y,pz=p.mesh.position.z;
        sPos[si*3]=px+(Math.random()-.5)*.2;
        sPos[si*3+1]=py+.05;
        sPos[si*3+2]=pz+(Math.random()-.5)*.2;
        sVel[si*3]=(Math.random()-.5)*.04;
        sVel[si*3+1]=.04+Math.random()*.07;
        sVel[si*3+2]=(Math.random()-.5)*.04;
        sLife[si]=.3+Math.random()*.4;
      }

      if(p.burnProgress>=1.0){
        scene.remove(p.mesh);
        p.geo.dispose(); p.mat.dispose();
        p.state='done';
      }
    }
  }
}

// â”€â”€â”€ BUTTON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
document.getElementById('btn-paper').addEventListener('click',function(){
  createPaper();
  this.disabled=true;
  setTimeout(()=>{ this.disabled=false; },1200);
});

// â”€â”€â”€ MAIN LOOP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let clock=0;
let fireBoost = 0;      // 0=normal, 1=fully boosted when paper lands
const _clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt = _clock.getDelta();
  clock += dt;

  // Decay fire boost smoothly
  fireBoost *= 0.991;

  // Update fire shader uniforms (time + boost)
  fireMats.forEach(m=>{ m.uniforms.time.value=clock; m.uniforms.boost.value=fireBoost; });
  smokeMat.uniforms.time.value=clock;

  // Sparks
  for(let i=0;i<SPARK_N;i++){
    sLife[i]-=.007+Math.random()*.004;
    sPos[i*3]  +=sVel[i*3]  +(Math.random()-.5)*.006;
    sPos[i*3+1]+=sVel[i*3+1];
    sPos[i*3+2]+=sVel[i*3+2]+(Math.random()-.5)*.006;
    if(sLife[i]<=0||sPos[i*3+1]>5.5) resetSpark(i);
  }
  sparkGeo.attributes.position.needsUpdate=true;

  // Dynamic ground embers â€” per-point size pulse + drift + color flicker
  for(let i=0;i<EMBER_N;i++){
    ePhase[i] += 0.05 + Math.random()*0.04; // fast individual pulse
    const pulse = 0.5 + 0.5*Math.sin(ePhase[i]);
    const pulse2= 0.5 + 0.5*Math.sin(ePhase[i]*1.7 + 1.3); // second harmonic

    // Drift ground position
    eBase[i*3]   += eVelE[i*2];
    eBase[i*3+2] += eVelE[i*2+1];
    const dx=eBase[i*3], dz=eBase[i*3+2];
    if(Math.sqrt(dx*dx+dz*dz) > 1.7){ eVelE[i*2]*=-1; eVelE[i*2+1]*=-1; }

    // Position: jitter visibly
    ePos[i*3]   = eBase[i*3]   + (Math.random()-.5)*0.04;
    ePos[i*3+1] = 0.02 + pulse*0.06;
    ePos[i*3+2] = eBase[i*3+2] + (Math.random()-.5)*0.04;

    // Size pulses dramatically between small and big
    eSize[i] = (0.5 + pulse*1.8 + pulse2*0.6) * (1.0 + fireBoost*2.5);

    // Color: dark red â†’ orange â†’ yellow based on pulse + boost
    const heat = pulse * (1.0 + fireBoost * 2.0);
    eCol[i*3]   = Math.min(1.0, 0.6 + heat*0.4);
    eCol[i*3+1] = Math.min(1.0, heat*0.55);
    eCol[i*3+2] = Math.min(1.0, Math.max(0, heat*0.15 - 0.1));

    // During boost, some embers launch as sparks
    if(fireBoost>0.25 && Math.random()<fireBoost*0.06){
      const si=Math.floor(Math.random()*SPARK_N);
      sPos[si*3]=ePos[i*3]; sPos[si*3+1]=0.08; sPos[si*3+2]=ePos[i*3+2];
      sVel[si*3]=(Math.random()-.5)*.04; sVel[si*3+1]=.07+Math.random()*.1; sVel[si*3+2]=(Math.random()-.5)*.04;
      sLife[si]=.4+Math.random()*.5;
    }
  }
  emberGeo2.attributes.position.needsUpdate=true;
  emberGeo2.attributes.color.needsUpdate=true;
  emberGeo2.attributes.aSize.needsUpdate=true;

  // Fire light â€” base flicker + boost
  const flk=Math.sin(clock*9.1)*.18+Math.sin(clock*13.7)*.1+Math.sin(clock*6.3)*.07;
  fireLight.intensity  = 2.9 + flk + fireBoost*4.0;
  fireLight2.intensity = 1.3 + flk*.6 + fireBoost*2.5;
  fireLight.color.setHSL(.07+Math.sin(clock*4.3)*.015, 1, Math.min(0.72,.56+fireBoost*.16));

  updatePapers(dt);
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
